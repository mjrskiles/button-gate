#include "core/coordinator.h"
#include "modes/mode_handlers.h"
#include "hardware/hal_interface.h"
#include "utility/progmem.h"
#include <stddef.h>

/**
 * @file coordinator.c
 * @brief Gatekeeper application coordinator implementation
 *
 * Implements the three-level FSM hierarchy and event routing.
 */

// =============================================================================
// Forward declarations for action functions
// =============================================================================

static void action_enter_menu(void);
static void action_exit_menu(void);
static void action_next_mode(void);
static void action_next_page(void);
static void action_cycle_value(void);

// Global pointer for action functions (set during update)
static Coordinator *g_coord = NULL;

// =============================================================================
// State definitions
// =============================================================================

// Top-level states (PERFORM / MENU)
static const State top_states[] PROGMEM_ATTR = {
    { TOP_PERFORM, NULL, NULL, NULL },
    { TOP_MENU,    NULL, NULL, NULL },
};

// Mode states (signal processing modes)
// Entry/exit/update functions will be added in AP-003 (mode handlers)
static const State mode_states[] PROGMEM_ATTR = {
    { MODE_GATE,    NULL, NULL, NULL },
    { MODE_TRIGGER, NULL, NULL, NULL },
    { MODE_TOGGLE,  NULL, NULL, NULL },
    { MODE_DIVIDE,  NULL, NULL, NULL },
    { MODE_CYCLE,   NULL, NULL, NULL },
};

// Menu page states
// Entry functions could display page indicator, exit could save
static const State menu_states[] PROGMEM_ATTR = {
    { PAGE_GATE_CV,           NULL, NULL, NULL },
    { PAGE_TRIGGER_BEHAVIOR,  NULL, NULL, NULL },
    { PAGE_TRIGGER_PULSE_LEN, NULL, NULL, NULL },
    { PAGE_TOGGLE_BEHAVIOR,   NULL, NULL, NULL },
    { PAGE_DIVIDE_DIVISOR,    NULL, NULL, NULL },
    { PAGE_CYCLE_PATTERN,     NULL, NULL, NULL },
    { PAGE_CV_GLOBAL,         NULL, NULL, NULL },
    { PAGE_MENU_TIMEOUT,      NULL, NULL, NULL },
};

// =============================================================================
// Transition tables
// =============================================================================

// Top-level transitions
static const Transition top_transitions[] PROGMEM_ATTR = {
    // Enter menu: A:hold + B:tap gesture
    { TOP_PERFORM, EVT_MENU_ENTER, TOP_MENU,    action_enter_menu },

    // Exit menu: A:release (EVT_MENU_EXIT generated by event processor context)
    // For now, use A_RELEASE when in menu
    { TOP_MENU,    EVT_A_RELEASE,  TOP_PERFORM, action_exit_menu },

    // Exit menu: timeout
    { TOP_MENU,    EVT_TIMEOUT,    TOP_PERFORM, action_exit_menu },
};

// Mode transitions (mode change gesture works from any mode)
static const Transition mode_transitions[] PROGMEM_ATTR = {
    // B:hold + A:hold = advance to next mode
    { FSM_ANY_STATE, EVT_MODE_CHANGE, FSM_NO_TRANSITION, action_next_mode },
};

// Menu transitions (navigation within menu)
static const Transition menu_transitions[] PROGMEM_ATTR = {
    // A:tap = next page
    { FSM_ANY_STATE, EVT_A_TAP, FSM_NO_TRANSITION, action_next_page },

    // B:tap = cycle value on current page
    { FSM_ANY_STATE, EVT_B_TAP, FSM_NO_TRANSITION, action_cycle_value },
};

// =============================================================================
// Action functions
// =============================================================================

static void action_enter_menu(void) {
    if (!g_coord) return;

    // Save current mode for context-aware page selection
    g_coord->menu_entry_mode = fsm_get_state(&g_coord->mode_fsm);
    g_coord->menu_enter_time = p_hal->millis();
    g_coord->last_activity = g_coord->menu_enter_time;

    // Jump to mode-relevant page
    MenuPage start_page = mode_to_start_page((ModeState)g_coord->menu_entry_mode);
    fsm_set_state(&g_coord->menu_fsm, start_page);
}

static void action_exit_menu(void) {
    if (!g_coord) return;

    // Save settings on menu exit
    if (g_coord->settings) {
        g_coord->settings->mode = fsm_get_state(&g_coord->mode_fsm);
        app_init_save_settings(g_coord->settings);
    }
}

static void action_next_mode(void) {
    if (!g_coord) return;

    uint8_t current = fsm_get_state(&g_coord->mode_fsm);
    uint8_t next = (current + 1) % MODE_COUNT;
    fsm_set_state(&g_coord->mode_fsm, next);

    // Initialize context for new mode
    mode_handler_init(next, &g_coord->mode_ctx);

    // Update activity timestamp
    g_coord->last_activity = p_hal->millis();
}

static void action_next_page(void) {
    if (!g_coord) return;

    uint8_t current = fsm_get_state(&g_coord->menu_fsm);
    uint8_t next = (current + 1) % PAGE_COUNT;
    fsm_set_state(&g_coord->menu_fsm, next);

    // Update activity timestamp
    g_coord->last_activity = p_hal->millis();
}

static void action_cycle_value(void) {
    if (!g_coord) return;

    // TODO: Implement per-page value cycling in AP-003
    // For now, just update activity timestamp
    g_coord->last_activity = p_hal->millis();
}

// =============================================================================
// Public API
// =============================================================================

void coordinator_init(Coordinator *coord, AppSettings *settings) {
    if (!coord) return;

    coord->settings = settings;
    coord->menu_entry_mode = MODE_GATE;
    coord->menu_enter_time = 0;
    coord->last_activity = 0;
    coord->output_state = false;

    // Initialize event processor
    event_processor_init(&coord->events);

    // Initialize mode handler context (default to gate mode)
    mode_handler_init(MODE_GATE, &coord->mode_ctx);

    // Initialize top-level FSM
    fsm_init(&coord->top_fsm,
             top_states, TOP_STATE_COUNT,
             top_transitions, sizeof(top_transitions) / sizeof(top_transitions[0]),
             TOP_PERFORM);

    // Initialize mode FSM
    fsm_init(&coord->mode_fsm,
             mode_states, MODE_COUNT,
             mode_transitions, sizeof(mode_transitions) / sizeof(mode_transitions[0]),
             MODE_GATE);

    // Initialize menu FSM
    fsm_init(&coord->menu_fsm,
             menu_states, PAGE_COUNT,
             menu_transitions, sizeof(menu_transitions) / sizeof(menu_transitions[0]),
             PAGE_GATE_CV);
}

void coordinator_start(Coordinator *coord) {
    if (!coord) return;

    // Start all FSMs
    fsm_start(&coord->top_fsm);
    fsm_start(&coord->mode_fsm);
    fsm_start(&coord->menu_fsm);

    coord->last_activity = p_hal->millis();
}

void coordinator_update(Coordinator *coord) {
    if (!coord) return;

    // Set global pointer for action functions
    g_coord = coord;

    // Build input state from HAL
    EventInput input = {
        .button_a = p_hal->read_pin(p_hal->button_a_pin),
        .button_b = p_hal->read_pin(p_hal->button_b_pin),
        .cv_in = false,  // TODO: Add CV input pin to HAL
        .current_time = p_hal->millis()
    };

    // Process input to get event
    Event event = event_processor_update(&coord->events, &input);

    // Route event to appropriate FSM based on current top-level state
    if (event != EVT_NONE) {
        TopState top_state = (TopState)fsm_get_state(&coord->top_fsm);

        // Top-level transitions (menu enter/exit)
        bool handled = fsm_process_event(&coord->top_fsm, event);

        if (!handled) {
            if (top_state == TOP_PERFORM) {
                // In perform mode: route to mode FSM
                fsm_process_event(&coord->mode_fsm, event);
            } else {
                // In menu mode: route to menu FSM
                fsm_process_event(&coord->menu_fsm, event);
            }
        }
    }

    // Check menu timeout
    if (fsm_get_state(&coord->top_fsm) == TOP_MENU) {
        uint32_t elapsed = p_hal->millis() - coord->last_activity;
        if (elapsed >= MENU_TIMEOUT_MS) {
            fsm_process_event(&coord->top_fsm, EVT_TIMEOUT);
        }
    }

    // Update current mode (run mode handler)
    // In perform mode, process input through mode handler
    if (fsm_get_state(&coord->top_fsm) == TOP_PERFORM) {
        ModeState mode = (ModeState)fsm_get_state(&coord->mode_fsm);
        bool input_state = event_processor_a_pressed(&coord->events);

        mode_handler_process(mode, &coord->mode_ctx, input_state, &coord->output_state);
    }

    // Clear global pointer
    g_coord = NULL;
}

TopState coordinator_get_top_state(const Coordinator *coord) {
    if (!coord) return TOP_PERFORM;
    return (TopState)fsm_get_state(&coord->top_fsm);
}

ModeState coordinator_get_mode(const Coordinator *coord) {
    if (!coord) return MODE_GATE;
    return (ModeState)fsm_get_state(&coord->mode_fsm);
}

void coordinator_set_mode(Coordinator *coord, ModeState mode) {
    if (!coord) return;
    if (mode >= MODE_COUNT) return;
    fsm_set_state(&coord->mode_fsm, mode);
    mode_handler_init(mode, &coord->mode_ctx);
}

bool coordinator_in_menu(const Coordinator *coord) {
    if (!coord) return false;
    return fsm_get_state(&coord->top_fsm) == TOP_MENU;
}

MenuPage coordinator_get_page(const Coordinator *coord) {
    if (!coord) return PAGE_GATE_CV;
    return (MenuPage)fsm_get_state(&coord->menu_fsm);
}

bool coordinator_get_output(const Coordinator *coord) {
    if (!coord) return false;
    return coord->output_state;
}

void coordinator_get_led_feedback(const Coordinator *coord, LEDFeedback *feedback) {
    if (!coord || !feedback) return;

    ModeState mode = (ModeState)fsm_get_state(&coord->mode_fsm);
    mode_handler_get_led(mode, &coord->mode_ctx, feedback);
}
